using System;
using System.Collections.Generic;
using System.Threading;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.U2D;
using UnityEngine.UI;
using YooAsset;

namespace Framework
{
    public abstract class UIPanelBase<TPanel> : MonoBehaviour, IUIPanel
        where TPanel : UIPanelBase<TPanel>
    {
        public abstract string PackageName { get; }
        public abstract string PanelName { get; }

        public IUIPanelData uiPanelData;
        //面板默认所属层级（子类可重写）
        public virtual UILayerEnum DefaultLayer => UILayerEnum.Normal;
        public virtual bool EnableClose => true;
        //面板状态
        private bool _isOpen = false;
        private bool _isVisible = false;

        private Dictionary<string, AssetHandle> _assetHandles = new Dictionary<string, AssetHandle>();

        private List<Button> _buttons = new List<Button>();
        private List<EventTrigger> _clickTriggers = new List<EventTrigger>();
        private List<EventTrigger> _longPressTriggers = new List<EventTrigger>();
        private List<CancellationTokenSource> _longPressCts = new List<CancellationTokenSource>();
        private List<EventTrigger> _dragTriggers = new List<EventTrigger>();

        /// <summary>
        /// 当前正在拖拽的数据（用于在 DragSource 和 DropTarget 之间传递）
        /// </summary>
        private static object CurrentDragData { get; set; }

        /// <summary>
        /// 当前拖拽的幽灵对象（透明副本）
        /// </summary>
        private static GameObject _dragGhost;

        /// <summary>
        /// 拖拽时使用的根Canvas缓存
        /// </summary>
        private static Canvas _dragRootCanvas;

        public virtual bool CanOpen()
        {
            if (_isOpen)
            {
                return false;
            }

            return OnCanOpen();
        }

        public abstract bool OnCanOpen();


        public virtual async UniTask OpenAsync(IUIPanelData data = null)
        {
            uiPanelData = data;
            if (!CanOpen())
            {
                UniLogger.LogError($"[UI] Panel {PanelName} cannot open (CanOpen returned false)");
                return;
            }

            _isOpen = true;

            Clear();

            OnOpen();

            await UniTask.Yield();

            Show();
        }

        public virtual void Show()
        {
            if (_isVisible)
            {
                //UniLogger.Log($"[UI] Panel {PanelName} is already visible");
                return;
            }
            _isVisible = true;
            this.gameObject.SetActive(_isVisible);
            OnShow();
        }

        public virtual void Hide()
        {
            if (!_isVisible)
            {
                return;
            }
            _isVisible = false;
            this.gameObject.SetActive(_isVisible);
            OnHide();
        }

        public virtual void Close()
        {
            if (!_isOpen)
            {
                return;
            }

            try
            {
                Clear();

                try { OnClose(); }
                catch (Exception e) { UniLogger.LogError($"[UI] OnClose error: {PanelName}\n{e}"); }
            }
            finally
            {
                _isVisible = false;
                _isOpen = false;
                //销毁掉自己
                GameObject.Destroy(this.gameObject);
            }
        }

        private void Clear()
        {
            foreach (var handle in _assetHandles.Values)
            {
                handle.Release();
            }

            _assetHandles?.Clear();


            foreach (var button in _buttons)
            {
                button.onClick.RemoveAllListeners();
            }
            _buttons?.Clear();


            foreach (var trigger in _clickTriggers)
            {
                // 移除旧的点击事件
                trigger?.triggers.RemoveAll(e => e.eventID == EventTriggerType.PointerClick);
            }
            _clickTriggers?.Clear();

            // 清理长按事件
            foreach (var cts in _longPressCts)
            {
                cts?.Cancel();
                cts?.Dispose();
            }
            _longPressCts?.Clear();

            foreach (var trigger in _longPressTriggers)
            {
                trigger?.triggers.RemoveAll(e =>
                    e.eventID == EventTriggerType.PointerDown ||
                    e.eventID == EventTriggerType.PointerUp ||
                    e.eventID == EventTriggerType.PointerExit);
            }
            _longPressTriggers?.Clear();

            foreach (var trigger in _dragTriggers)
            {
                // 移除旧的拖拽事件
                trigger?.triggers.RemoveAll(e => e.eventID == EventTriggerType.BeginDrag || e.eventID == EventTriggerType.Drag || e.eventID == EventTriggerType.EndDrag || e.eventID == EventTriggerType.Drop);
            }
            _dragTriggers?.Clear();
        }

        #region UI Helpers
        protected void SetText(Text text, string content)
        {
            if (text != null) text.text = content;
        }

        protected void SetImage(Image image, Sprite sprite, bool isSetNativeSize = true)
        {
            if (image != null) image.sprite = sprite;
            if (isSetNativeSize) image.SetNativeSize();
        }

        /// <summary>
        /// 设置图片
        /// </summary>
        /// <param name="image"></param>
        /// <param name="url">atlas/sprite</param>
        protected void SetImage(Image image, string url, bool isRemote = true, bool isSetNativeSize = true)
        {
            if (string.IsNullOrEmpty(url))
            {
                return;
            }
            int splitIndex = url.IndexOf('/');
            if (splitIndex <= 0 || splitIndex == url.Length - 1)
            {
                return; // 格式不对
            }

            var package = isRemote ? ResKit.Instance.GetDefaultPackage() : ResKit.Instance.GetBuiltinPackage();

            if (!_assetHandles.TryGetValue(url, out var handler))
            {

                string prefix = isRemote ? "Remote" : "Builtin";
                handler = package.LoadAssetSync($"Assets/Res/{prefix}/UI/Atlases/{url[..splitIndex]}.spriteatlas");
                _assetHandles.TryAdd(url, handler);
            }

            var result = handler.GetAssetObject<SpriteAtlas>().GetSprite(url[(splitIndex + 1)..]);
            SetImage(image, result, isSetNativeSize);
        }

        /// <summary>
        /// 绑定按钮点击事件
        /// </summary>
        protected void AddClick(Button button, Action action)
        {
            if (button == null) return;
            button.onClick.RemoveAllListeners();
            button.onClick.AddListener(() => OnClickWrapper(action));

            _buttons.Add(button);
        }

        /// <summary>
        /// 绑定按钮点击事件（带参数版）
        /// </summary>
        protected void AddClick<T>(Button button, T param, System.Action<T> action)
        {
            if (button == null) return;
            button.onClick.RemoveAllListeners();
            button.onClick.AddListener(() => OnClickWrapper(() => action?.Invoke(param)));

            _buttons.Add(button);
        }


        /// <summary>
        /// 为任意 GameObject 添加点击事件
        /// </summary>
        protected void AddClick(GameObject go, Action action)
        {
            if (go == null) return;
            AddClickToGameObject(go, action);
        }
        /// <summary>
        /// 为任意 GameObject 添加点击事件（带参数版）
        /// </summary>
        protected void AddClick<T>(GameObject go, T param, Action<T> action)
        {
            if (go == null) return;
            AddClickToGameObject(go, () => action?.Invoke(param));
        }

        /// <summary>
        /// 内部方法：通过 EventTrigger 实现点击
        /// </summary>
        private void AddClickToGameObject(GameObject go, Action action)
        {
            var trigger = GetOrAddEventTrigger(go);

            // 移除旧的点击事件
            trigger.triggers.RemoveAll(e => e.eventID == EventTriggerType.PointerClick);

            // 添加新的点击事件
            var entry = new EventTrigger.Entry { eventID = EventTriggerType.PointerClick };
            entry.callback.AddListener((_) => OnClickWrapper(action));
            trigger.triggers.Add(entry);

            _clickTriggers.Add(trigger);
        }

        /// <summary>
        /// 按钮点击的包装器
        /// </summary>
        private void OnClickWrapper(Action action, string soundName = "UI_Click")
        {
            //AudioKit.Instance.PlaySound(soundName); 
            action?.Invoke();
        }

        /// <summary>
        /// 解绑按钮
        /// </summary>
        protected void RemoveClick(Button button)
        {
            if (button != null)
            {
                button.onClick.RemoveAllListeners();
                _buttons.Remove(button);
            }
        }

        /// <summary>
        /// 解绑点击事件
        /// </summary>
        protected void RemoveClick(GameObject go)
        {
            if (go == null) return;
            var trigger = go.GetComponent<EventTrigger>();
            if (trigger != null)
            {
                trigger.triggers.RemoveAll(e => e.eventID == EventTriggerType.PointerClick);
                _clickTriggers.Remove(trigger);
            }
        }

        /// <summary>
        /// 添加持续长按事件（长按期间持续触发）
        /// </summary>
        /// <param name="go">目标对象</param>
        /// <param name="onRepeat">持续触发的回调</param>
        /// <param name="interval">触发间隔（秒）</param>
        /// <param name="delay">首次触发前的延迟（秒）</param>
        protected void AddLongPressRepeat(GameObject go, Action onRepeat, float interval = 0.1f, float delay = 0.3f)
        {
            if (go == null || onRepeat == null) return;

            var trigger = GetOrAddEventTrigger(go);
            CancellationTokenSource cts = null;

            // 按下开始
            AddTriggerEntry(trigger, EventTriggerType.PointerDown, (_) =>
            {
                cts = new CancellationTokenSource();
                _longPressCts.Add(cts);
                LongPressRepeatAsync(onRepeat, interval, delay, cts.Token).Forget();
            });

            // 抬起停止
            AddTriggerEntry(trigger, EventTriggerType.PointerUp, (_) =>
            {
                CancelLongPress(ref cts);
            });

            // 离开停止
            AddTriggerEntry(trigger, EventTriggerType.PointerExit, (_) =>
            {
                CancelLongPress(ref cts);
            });

            _longPressTriggers.Add(trigger);
        }

        /// <summary>
        /// 添加延迟长按事件（长按达到指定时间后触发一次）
        /// </summary>
        /// <param name="go">目标对象</param>
        /// <param name="onHold">长按成功后的回调</param>
        /// <param name="holdTime">需要长按的时间（秒）</param>
        /// <param name="onProgress">长按进度回调（可选，参数为0-1的进度值）</param>
        protected void AddLongPressHold(GameObject go, Action onHold, float holdTime = 0.5f, Action<float> onProgress = null)
        {
            if (go == null || onHold == null) return;

            var trigger = GetOrAddEventTrigger(go);
            CancellationTokenSource cts = null;

            // 按下开始计时
            AddTriggerEntry(trigger, EventTriggerType.PointerDown, (_) =>
            {
                cts = new CancellationTokenSource();
                _longPressCts.Add(cts);
                LongPressHoldAsync(onHold, holdTime, onProgress, cts.Token).Forget();
            });

            // 抬起取消
            AddTriggerEntry(trigger, EventTriggerType.PointerUp, (_) =>
            {
                CancelLongPress(ref cts);
                onProgress?.Invoke(0f); // 重置进度
            });

            // 离开取消
            AddTriggerEntry(trigger, EventTriggerType.PointerExit, (_) =>
            {
                CancelLongPress(ref cts);
                onProgress?.Invoke(0f); // 重置进度
            });

            _longPressTriggers.Add(trigger);
        }

        /// <summary>
        /// 持续长按异步任务
        /// </summary>
        private async UniTaskVoid LongPressRepeatAsync(Action onRepeat, float interval, float delay, CancellationToken token)
        {
            try
            {
                // 首次延迟
                await UniTask.Delay(TimeSpan.FromSeconds(delay), cancellationToken: token);

                // 持续触发
                while (!token.IsCancellationRequested)
                {
                    onRepeat?.Invoke();
                    await UniTask.Delay(TimeSpan.FromSeconds(interval), cancellationToken: token);
                }
            }
            catch (OperationCanceledException)
            {
                // 正常取消，不处理
            }
        }

        /// <summary>
        /// 延迟长按异步任务
        /// </summary>
        private async UniTaskVoid LongPressHoldAsync(Action onHold, float holdTime, Action<float> onProgress, CancellationToken token)
        {
            try
            {
                float elapsed = 0f;

                while (elapsed < holdTime)
                {
                    await UniTask.Yield(token);
                    elapsed += Time.deltaTime;
                    onProgress?.Invoke(Mathf.Clamp01(elapsed / holdTime));
                }

                onHold?.Invoke();
            }
            catch (OperationCanceledException)
            {
                // 正常取消，不处理
            }
        }

        /// <summary>
        /// 取消长按任务
        /// </summary>
        private void CancelLongPress(ref CancellationTokenSource cts)
        {
            if (cts != null)
            {
                cts.Cancel();
                cts.Dispose();
                _longPressCts.Remove(cts);
                cts = null;
            }
        }

        /// <summary>
        /// 移除长按事件
        /// </summary>
        protected void RemoveLongPress(GameObject go)
        {
            if (go == null) return;
            var trigger = go.GetComponent<EventTrigger>();
            if (trigger != null)
            {
                trigger.triggers.RemoveAll(e =>
                    e.eventID == EventTriggerType.PointerDown ||
                    e.eventID == EventTriggerType.PointerUp ||
                    e.eventID == EventTriggerType.PointerExit);
                _longPressTriggers.Remove(trigger);
            }
        }

        /// <summary>
        /// 添加简单拖拽（拖动时移动目标）
        /// </summary>
        /// <param name="handle">拖拽手柄（如标题栏）</param>
        /// <param name="target">被移动的目标（默认为 handle 自身）</param>
        protected void AddDrag(GameObject handle, Transform target = null)
        {
            if (handle == null) return;
            if (target == null) target = handle.transform;

            var trigger = GetOrAddEventTrigger(handle);

            // 记录拖拽开始时的偏移
            Vector2 dragOffset = Vector2.zero;

            // BeginDrag：记录偏移
            AddTriggerEntry(trigger, EventTriggerType.BeginDrag, (data) =>
            {
                var pointerData = data as PointerEventData;
                RectTransformUtility.ScreenPointToLocalPointInRectangle(
                    target.parent as RectTransform,
                    pointerData.position,
                    pointerData.pressEventCamera,
                    out Vector2 localPoint);
                dragOffset = (Vector2)target.localPosition - localPoint;
            });

            // Drag：更新位置
            AddTriggerEntry(trigger, EventTriggerType.Drag, (data) =>
            {
                var pointerData = data as PointerEventData;
                RectTransformUtility.ScreenPointToLocalPointInRectangle(
                    target.parent as RectTransform,
                    pointerData.position,
                    pointerData.pressEventCamera,
                    out Vector2 localPoint);
                target.localPosition = localPoint + dragOffset;
            });

            _dragTriggers.Add(trigger);
        }

        /// <summary>
        /// 添加拖拽源（可被拖走的元素，无拖拽副本）
        /// </summary>
        protected void AddDragSource<T>(GameObject go, T data, Action<T> onBeginDrag = null, Action<T> onEndDrag = null)
        {
            AddDragSource(go, data, 0f, onBeginDrag, onEndDrag);
        }

        /// <summary>
        /// 添加拖拽源（可被拖走的元素，带拖拽副本）
        /// </summary>
        /// <param name="go">拖拽源对象</param>
        /// <param name="data">传递的数据</param>
        /// <param name="ghostAlpha">拖拽副本的透明度（0-1，0表示不创建副本）</param>
        /// <param name="onBeginDrag">开始拖拽回调</param>
        /// <param name="onEndDrag">结束拖拽回调</param>
        protected void AddDragSource<T>(GameObject go, T data, float ghostAlpha, Action<T> onBeginDrag = null, Action<T> onEndDrag = null)
        {
            if (go == null) return;

            var trigger = GetOrAddEventTrigger(go);

            AddTriggerEntry(trigger, EventTriggerType.BeginDrag, (baseData) =>
            {
                CurrentDragData = data;

                // 创建拖拽幽灵（透明副本）
                if (ghostAlpha > 0f)
                {
                    _dragGhost = CreateDragGhost(go, ghostAlpha);
                    var pointerData = baseData as PointerEventData;
                    UpdateGhostPosition(pointerData);
                }

                onBeginDrag?.Invoke(data);
            });

            AddTriggerEntry(trigger, EventTriggerType.Drag, (baseData) =>
            {
                // 更新幽灵位置跟随鼠标
                if (_dragGhost != null)
                {
                    var pointerData = baseData as PointerEventData;
                    UpdateGhostPosition(pointerData);
                }
            });

            AddTriggerEntry(trigger, EventTriggerType.EndDrag, (_) =>
            {
                // 销毁幽灵
                DestroyDragGhost();

                onEndDrag?.Invoke(data);
                CurrentDragData = null;
            });

            _dragTriggers.Add(trigger);
        }

        /// <summary>
        /// 创建拖拽幽灵对象
        /// </summary>
        private GameObject CreateDragGhost(GameObject source, float alpha)
        {
            // 找到根 Canvas
            _dragRootCanvas = source.GetComponentInParent<Canvas>()?.rootCanvas;
            if (_dragRootCanvas == null)
            {
                UniLogger.LogError("[UI] Cannot find root canvas for drag ghost");
                return null;
            }

            // 复制源对象
            var ghost = GameObject.Instantiate(source, _dragRootCanvas.transform);
            ghost.name = "DragGhost";

            // 确保在最上层显示
            var rectTransform = ghost.GetComponent<RectTransform>();
            rectTransform.SetAsLastSibling();

            // 设置透明度并禁用交互
            SetupGhost(ghost, alpha);

            return ghost;
        }

        /// <summary>
        /// 设置幽灵对象的透明度和交互
        /// </summary>
        private void SetupGhost(GameObject ghost, float alpha)
        {
            // 添加或获取 CanvasGroup
            var canvasGroup = ghost.GetComponent<CanvasGroup>();
            if (canvasGroup == null)
            {
                canvasGroup = ghost.AddComponent<CanvasGroup>();
            }

            // 设置透明度
            canvasGroup.alpha = alpha;

            // 禁用交互（防止幽灵拦截射线）
            canvasGroup.blocksRaycasts = false;
            canvasGroup.interactable = false;
        }

        /// <summary>
        /// 更新幽灵位置
        /// </summary>
        private void UpdateGhostPosition(PointerEventData pointerData)
        {
            if (_dragGhost == null || _dragRootCanvas == null) return;

            var ghostRect = _dragGhost.GetComponent<RectTransform>();

            // 将屏幕坐标转换为 Canvas 本地坐标
            Camera camera = _dragRootCanvas.renderMode == RenderMode.ScreenSpaceOverlay ? null : _dragRootCanvas.worldCamera;
            RectTransformUtility.ScreenPointToLocalPointInRectangle(
                _dragRootCanvas.transform as RectTransform,
                pointerData.position,
                camera,
                out Vector2 localPoint);

            ghostRect.anchoredPosition = localPoint;
        }

        /// <summary>
        /// 销毁拖拽幽灵
        /// </summary>
        private void DestroyDragGhost()
        {
            if (_dragGhost != null)
            {
                GameObject.Destroy(_dragGhost);
                _dragGhost = null;
            }
            _dragRootCanvas = null;
        }

        /// <summary>
        /// 添加放置目标区域
        /// </summary>
        protected void AddDropTarget<T>(GameObject go, Action<T> onDrop)
        {
            if (go == null) return;

            var trigger = GetOrAddEventTrigger(go);

            AddTriggerEntry(trigger, EventTriggerType.Drop, (_) =>
            {
                if (CurrentDragData is T data)
                {
                    onDrop?.Invoke(data);
                }
            });

            _dragTriggers.Add(trigger);
        }

        /// <summary>
        /// 移除拖拽事件
        /// </summary>
        protected void RemoveDrag(GameObject go)
        {
            if (go == null) return;
            var trigger = go.GetComponent<EventTrigger>();
            if (trigger != null)
            {
                trigger.triggers.RemoveAll(e =>
                    e.eventID == EventTriggerType.BeginDrag ||
                    e.eventID == EventTriggerType.Drag ||
                    e.eventID == EventTriggerType.EndDrag ||
                    e.eventID == EventTriggerType.Drop);
                _dragTriggers.Remove(trigger);
            }
        }

        private void AddTriggerEntry(EventTrigger trigger, EventTriggerType type, UnityEngine.Events.UnityAction<BaseEventData> callback)
        {
            trigger.triggers.RemoveAll(e => e.eventID == type);
            var entry = new EventTrigger.Entry { eventID = type };
            entry.callback.AddListener(callback);
            trigger.triggers.Add(entry);
        }

        /// <summary>
        /// 获取或添加 EventTrigger 组件
        /// </summary>
        private EventTrigger GetOrAddEventTrigger(GameObject go)
        {
            var trigger = go.GetComponent<EventTrigger>();
            if (trigger == null)
            {
                trigger = go.AddComponent<EventTrigger>();
            }
            return trigger;
        }


        #endregion
        protected abstract void OnOpen();
        protected abstract void OnShow();
        protected abstract void OnHide();
        protected abstract void OnClose();


    }

}