using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using Scriban;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.UI;

namespace Framework.Editor
{
    /// <summary>
    /// UIKit 核心编辑器工具类：负责 UI 模板创建、组件绑定及自动化导出
    /// </summary>
    [InitializeOnLoad]
    public static class UIEditor
    {
        private const string k_AutoBindKey = "UIKit_AutoBind_Pending";
        private const string k_PendingSceneKey = "UIKit_Pending_Scene";

        static UIEditor()
        {
            // 注册 Hierarchy 面板的回调（Scene 视图的工具箱由 UIKitToolsWindow 管理）
            EditorApplication.hierarchyWindowItemOnGUI -= OnHierarchyGUI;
            EditorApplication.hierarchyWindowItemOnGUI += OnHierarchyGUI;
        }

        #region Hierarchy UI

        /// <summary>
        /// 在 Hierarchy 面板展示已绑定的节点标识
        /// </summary>
        private static void OnHierarchyGUI(int instanceID, Rect selectionRect)
        {
            GameObject obj = EditorUtility.InstanceIDToObject(instanceID) as GameObject;
            if (obj == null) return;

            var bind = obj.GetComponent<UINodeBind>();
            if (bind != null)
            {
                Rect labelRect = new Rect(selectionRect.xMax - 65, selectionRect.y, 65, selectionRect.height);
                GUIStyle style = new GUIStyle(EditorStyles.miniLabel)
                {
                    alignment = TextAnchor.MiddleRight,
                    normal = { textColor = new Color(0.4f, 0.8f, 1f) }
                };
                GUI.Label(labelRect, $"[{bind.ComponentType}]", style);
            }
        }

        #endregion

        #region UI 模板创建逻辑

        /// <summary>
        /// 执行 UI 场景模板的创建
        /// </summary>
        public static void ExecuteCreateUITemplate(string panelName, UIPanelDescription template)
        {
            string saveDir = Path.Combine(UIEditorConstants.UISceneSavePath, template.PackageName);
            UIEditorConstants.EnsureDirectory(saveDir);

            string scenePath = $"{saveDir}/{panelName}.unity";
            if (File.Exists(scenePath))
            {
                EditorUtility.DisplayDialog("提示", $"UI 界面 [{panelName}] 已存在！\n请检查是否重名或先手动删除旧场景。", "确定");
                return;
            }

            // 创建新场景
            var newScene = EditorSceneManager.NewScene(NewSceneSetup.EmptyScene, NewSceneMode.Single);

            // 1. 创建根节点并初始化元数据
            GameObject uiRoot = new GameObject(panelName);
            var desc = uiRoot.AddComponent<UIPanelDescription>();
            // 利用 CopySerialized 实现数据解耦拷贝
            EditorUtility.CopySerialized(template, desc);

            // 2. 创建环境节点
            GameObject mainCam = new GameObject("Main Camera", typeof(Camera));
            mainCam.transform.SetParent(uiRoot.transform);
            var cam = mainCam.GetComponent<Camera>();
            cam.clearFlags = CameraClearFlags.SolidColor;
            cam.backgroundColor = Color.black;

            GameObject light = new GameObject("Directional Light", typeof(Light));
            light.transform.SetParent(uiRoot.transform);
            light.GetComponent<Light>().type = LightType.Directional;

            // 3. 创建 UI 画布结构
            GameObject canvasGO = new GameObject("Canvas", typeof(Canvas), typeof(CanvasScaler), typeof(GraphicRaycaster));
            canvasGO.transform.SetParent(uiRoot.transform);
            canvasGO.GetComponent<Canvas>().renderMode = RenderMode.ScreenSpaceOverlay;

            CreateSubLayer(canvasGO.transform, UIEditorConstants.NotExportBottom);
            CreateSubLayer(canvasGO.transform, UIEditorConstants.ExportRoot);
            CreateSubLayer(canvasGO.transform, UIEditorConstants.NotExportTop);

            // 4. 事件系统
            GameObject eventSystem = new GameObject("EventSystem", typeof(UnityEngine.EventSystems.EventSystem), typeof(UnityEngine.EventSystems.StandaloneInputModule));
            eventSystem.transform.SetParent(uiRoot.transform);

            // 保存场景
            if (EditorSceneManager.SaveScene(newScene, scenePath))
            {
                AssetDatabase.Refresh();
                UniLogger.Log($"<color=green>UI 模板场景创建成功: {scenePath}</color>");
            }

            Selection.activeGameObject = uiRoot;
        }

        private static void CreateSubLayer(Transform parent, string name)
        {
            GameObject go = new GameObject(name, typeof(RectTransform));
            go.transform.SetParent(parent, false);
            RectTransform rt = go.GetComponent<RectTransform>();
            rt.anchorMin = Vector2.zero;
            rt.anchorMax = Vector2.one;
            rt.sizeDelta = Vector2.zero;
            rt.anchoredPosition = Vector2.zero;
        }

        #endregion

        #region 节点绑定与代码生成

        /// <summary>
        /// 批量为选中的对象添加 UINodeBind 脚本
        /// </summary>
        [MenuItem("Framework/UIKit/Bind UI Node &b", false, 0)]
        public static void AddBindComponent()
        {
            foreach (GameObject go in Selection.gameObjects)
            {
                if (go.GetComponent<UINodeBind>() == null)
                {
                    Undo.AddComponent<UINodeBind>(go);
                }
            }
        }

        /// <summary>
        /// 开始导出流程：验证 -> 代码生成 -> 等待编译
        /// </summary>
        public static void StartExportProcess()
        {
            var desc = UnityEngine.Object.FindFirstObjectByType<UIPanelDescription>();
            if (desc == null)
            {
                EditorUtility.DisplayDialog("错误", "场景未发现 UIPanelDescription，无法导出！", "确定");
                return;
            }

            GameObject exportRoot = GameObject.Find(UIEditorConstants.ExportRoot);
            if (exportRoot == null)
            {
                UniLogger.LogError($"未找到 {UIEditorConstants.ExportRoot}，请先创建模板！");
                return;
            }

            string panelName = EditorSceneManager.GetActiveScene().name;
            var bindNodes = exportRoot.GetComponentsInChildren<UINodeBind>(true);
            var members = new List<object>();
            HashSet<string> usedNames = new HashSet<string>();

            foreach (var node in bindNodes)
            {
                string finalName = node.GetFinalMemberName();
                if (!UIEditorHelper.IsValidVariableName(finalName, out string errorMsg))
                {
                    string path = UIEditorHelper.GetRelativePath(node.transform, exportRoot.transform);
                    UniLogger.LogError($"导出失败：节点 [{node.name}] 命名非法: {errorMsg}\n路径: {path}");
                    EditorUtility.DisplayDialog("非法命名", $"节点 [{node.name}] 变量名非法：\n{errorMsg}", "确定");
                    return;
                }

                if (usedNames.Contains(finalName))
                {
                    string path = UIEditorHelper.GetRelativePath(node.transform, exportRoot.transform);
                    UniLogger.LogError($"导出失败：重复的变量名 [{finalName}]\n路径: {path}");
                    EditorUtility.DisplayDialog("命名冲突", $"发现重复的变量名: {finalName}", "确定");
                    return;
                }

                usedNames.Add(finalName);
                members.Add(new { name = finalName, type = node.GetFinalComponentType().ToString() });
            }

            GenerateCode(panelName, members, desc);

            EditorPrefs.SetBool(k_AutoBindKey, true);
            EditorPrefs.SetString(k_PendingSceneKey, panelName);
            AssetDatabase.Refresh();

            if (!EditorApplication.isCompiling)
            {
                OnScriptsReloaded();
            }
        }

        private static void GenerateCode(string className, List<object> members, UIPanelDescription desc)
        {
            string baseClassName = desc.PanelType switch
            {
                Framework.UIType.Popup => "UIPopupPanelBase",
                Framework.UIType.Bar => "UIBarBase",
                _ => "UIPanelBase"
            };

            string fullBaseClass = $"{baseClassName}<{className}>";
            string templatePath = Path.Combine(Application.dataPath, "Scripts/Framework/Kit/UIKit/Editor/Templates/UIPanel.Generated.sbn");

            if (!File.Exists(templatePath))
            {
                UniLogger.LogError($"无法找到 Scriban 模板文件: {templatePath}");
                return;
            }

            try
            {
                string templateStr = File.ReadAllText(templatePath);
                var template = Template.Parse(templateStr);

                // 1. 生成 Generated 引用绑定代码
                var genContext = new { is_gen = true, namespace_name = desc.Namespace, class_name = className, members = members };
                string genResult = template.Render(genContext);
                string genPath = Path.Combine(UIEditorConstants.UIBindScripts, className + ".Generated.cs");

                if (!Directory.Exists(UIEditorConstants.UIBindScripts)) Directory.CreateDirectory(UIEditorConstants.UIBindScripts);
                File.WriteAllText(genPath, genResult, System.Text.Encoding.UTF8);

                // 2. 生成业务逻辑初始代码
                string logicDir = Path.Combine(UIEditorConstants.UILogicScripts, desc.PackageName);
                if (!Directory.Exists(logicDir)) Directory.CreateDirectory(logicDir);

                string logicPath = Path.Combine(logicDir, className + ".cs");
                if (!File.Exists(logicPath))
                {
                    var logicContext = new { is_gen = false, namespace_name = desc.Namespace, class_name = className, base_class = fullBaseClass, package_name = desc.PackageName };
                    string logicResult = template.Render(logicContext);
                    File.WriteAllText(logicPath, logicResult, System.Text.Encoding.UTF8);
                    UniLogger.Log($"<color=cyan>初始业务逻辑脚本已生成: {logicPath}</color>");
                }

                UniLogger.Log($"<color=white>UI 代码生成成功: {className}.Generated.cs</color>");
            }
            catch (Exception e)
            {
                UniLogger.LogError($"代码生成失败: {e.Message}");
            }
        }

        #endregion

        #region 编译后自动重绑定逻辑

        [DidReloadScripts]
        private static void OnScriptsReloaded()
        {
            if (!EditorPrefs.GetBool(k_AutoBindKey, false)) return;
            EditorPrefs.SetBool(k_AutoBindKey, false);

            string panelName = EditorPrefs.GetString(k_PendingSceneKey);
            PerformBinding(panelName);
        }

        private static void PerformBinding(string panelName)
        {
            // 1. 查找 ExportRoot
            GameObject exportRoot = GameObject.Find(UIEditorConstants.ExportRoot);
            if (exportRoot == null)
            {
                UniLogger.LogError($"导出失败：场景中找不到名为 {UIEditorConstants.ExportRoot} 的节点");
                return;
            }

            // 2. 获取描述信息以确定命名空间
            // 优先从 exportRoot 的父级找，找不到再全场景找
            var desc = exportRoot.GetComponentInParent<UIPanelDescription>()
                      ?? UnityEngine.Object.FindFirstObjectByType<UIPanelDescription>();

            string ns = desc != null ? desc.Namespace : "Game.UI";

            // 3. 反射获取类型
            Type type = Assembly.Load("Assembly-CSharp").GetType(ns + "." + panelName);
            if (type == null)
            {
                UniLogger.LogError($"绑定失败：在程序集中找不到类 {ns}.{panelName}，请检查代码是否有编译错误。");
                return;
            }

            // 4. 挂载或获取组件
            var comp = exportRoot.GetComponent(type) ?? exportRoot.AddComponent(type);
            var nodes = exportRoot.GetComponentsInChildren<UINodeBind>(true);

            foreach (var node in nodes)
            {
                var field = type.GetField(node.GetFinalMemberName());
                if (field != null)
                {
                    var targetComp = node.GetComponent(node.GetFinalComponentType().ToString());
                    field.SetValue(comp, targetComp);
                }
            }

            // 5. 执行最终导出
            FinalizePrefab(exportRoot, panelName);
        }

        private static void FinalizePrefab(GameObject exportRoot, string panelName)
        {

            var desc = exportRoot.GetComponentInParent<UIPanelDescription>()
                      ?? UnityEngine.Object.FindFirstObjectByType<UIPanelDescription>();

            UIPackageType pkgType = desc != null ? desc.PackageType : UIPackageType.Remote;

            // 获取正确的存储路径
            string folderPath = UIEditorConstants.GetUIPrefabDir(pkgType);
            UIEditorConstants.EnsureDirectory(folderPath);

            string prefabPath = $"{folderPath}/{panelName}.prefab";

            // 1. 保存场景原始对象
            PrefabUtility.SaveAsPrefabAsset(exportRoot, prefabPath);

            // 2. 加载内存副本并净化
            GameObject prefabContents = PrefabUtility.LoadPrefabContents(prefabPath);

            var nodes = prefabContents.GetComponentsInChildren<UINodeBind>(true);
            for (int i = nodes.Length - 1; i >= 0; i--)
            {
                UnityEngine.Object.DestroyImmediate(nodes[i]);
            }

            // 3. 回写并释放
            PrefabUtility.SaveAsPrefabAsset(prefabContents, prefabPath);
            PrefabUtility.UnloadPrefabContents(prefabContents);

            UniLogger.Log($"<color=green>UI 导出成功！</color> Prefab [{panelName}] 已保存至: {prefabPath}");
        }

        /// <summary>
        /// 清理已删除 UI 场景对应的废弃资源（Generated 代码和 Prefab）
        /// </summary>
        public static void CleanupOrphanedAssets()
        {
            // 1. 获取所有有效的 UI 场景名（从 CreateUIScenes 目录递归查找）
            HashSet<string> validPanelNames = new HashSet<string>();
            if (Directory.Exists(UIEditorConstants.UISceneSavePath))
            {
                // 查找所有子目录下的 .unity 文件
                string[] sceneFiles = Directory.GetFiles(UIEditorConstants.UISceneSavePath, "*.unity", SearchOption.AllDirectories);
                foreach (var file in sceneFiles)
                {
                    validPanelNames.Add(Path.GetFileNameWithoutExtension(file));
                }
            }

            bool changed = false;

            // 2. 清理 Generated 脚本 (Assets/Scripts/Generated/UI)
            if (Directory.Exists(UIEditorConstants.UIBindScripts))
            {
                string[] genFiles = Directory.GetFiles(UIEditorConstants.UIBindScripts, "*.Generated.cs", SearchOption.TopDirectoryOnly);
                foreach (var file in genFiles)
                {
                    string panelName = Path.GetFileName(file).Replace(".Generated.cs", "");
                    if (!validPanelNames.Contains(panelName))
                    {
                        // 转换为 Unity 资产路径进行删除
                        string assetPath = UIEditorHelper.ToAssetPath(file);
                        if (AssetDatabase.DeleteAsset(assetPath))
                        {
                            UniLogger.Log($"[UIKit] 清理废弃脚本: {assetPath}");
                            changed = true;
                        }
                    }
                }
            }

            // 3. 清理 Prefabs (检查 Builtin 和 Remote 两个目录)
            string[] prefabDirs = { UIEditorConstants.UIPrefabSaveBuiltinPath, UIEditorConstants.UIPrefabSavePath };
            foreach (var dir in prefabDirs)
            {
                if (Directory.Exists(dir))
                {
                    string[] prefabFiles = Directory.GetFiles(dir, "*.prefab", SearchOption.TopDirectoryOnly);
                    foreach (var file in prefabFiles)
                    {
                        string panelName = Path.GetFileNameWithoutExtension(file);
                        if (!validPanelNames.Contains(panelName))
                        {
                            string assetPath = UIEditorHelper.ToAssetPath(file);
                            if (AssetDatabase.DeleteAsset(assetPath))
                            {
                                UniLogger.Log($"[UIKit] 清理废弃 Prefab: {assetPath}");
                                changed = true;
                            }
                        }
                    }
                }
            }

            if (changed)
            {
                AssetDatabase.Refresh();
                EditorUtility.DisplayDialog("提示", "清理完成！请查看控制台日志。", "确定");
            }
            else
            {
                EditorUtility.DisplayDialog("提示", "未发现需要清理的废弃资源。", "确定");
            }
        }

        #endregion
    }

    #region 编辑器弹窗与辅助类

    public class UIPanelNameInputWindow : EditorWindow
    {
        private string _panelName = "";
        private GameObject _tempGO;
        private UIPanelDescription _tempDesc;
        private SerializedObject _serializedObject;
        private Action<string, UIPanelDescription> _onConfirm;

        public static void ShowWindow(Action<string, UIPanelDescription> onConfirm)
        {
            var window = GetWindow<UIPanelNameInputWindow>(true, "创建新 UI 面板", true);
            window._onConfirm = onConfirm;
            window.minSize = new Vector2(350, 280); // 稍微增加一点高度
            window.CenterOnMainWin();
        }

        private void OnEnable()
        {
            // 重点：改用 DontSave 而不是 HideAndDontSave，防止 Unity 锁定对象
            _tempGO = new GameObject("TempDesc") { hideFlags = HideFlags.DontSave };
            _tempDesc = _tempGO.AddComponent<UIPanelDescription>();
            _serializedObject = new SerializedObject(_tempDesc);
        }

        private void OnDisable()
        {
            if (_tempGO) DestroyImmediate(_tempGO);
        }

        private void OnGUI()
        {
            // 强制开启 GUI 可用状态
            GUI.enabled = true;

            EditorGUILayout.Space(10);

            // 1. 绘制面板名称
            GUI.SetNextControlName("PanelNameField");
            _panelName = EditorGUILayout.TextField("面板名称 (Name):", _panelName);

            EditorGUILayout.Space(5);
            EditorGUILayout.LabelField("", GUI.skin.horizontalSlider);

            // 2. 自动绘制 UIPanelDescription 字段
            if (_serializedObject != null)
            {
                _serializedObject.Update();

                EditorGUI.BeginChangeCheck(); // 开始检查修改

                SerializedProperty iterator = _serializedObject.GetIterator();
                bool enterChildren = true;
                while (iterator.NextVisible(enterChildren))
                {
                    enterChildren = false;
                    if (iterator.name == "m_Script") continue; // 跳过 Script 字段

                    EditorGUILayout.PropertyField(iterator, true);
                }

                if (EditorGUI.EndChangeCheck())
                {
                    _serializedObject.ApplyModifiedProperties();
                    Repaint(); // 强制刷新窗口
                }
            }

            GUILayout.FlexibleSpace();

            if (GUILayout.Button("确认创建", GUILayout.Height(35)))
            {
                ConfirmAndClose();
            }
            EditorGUILayout.Space(10);
        }

        private void ConfirmAndClose()
        {
            if (string.IsNullOrEmpty(_panelName))
            {
                EditorUtility.DisplayDialog("错误", "面板名称不能为空！", "确定");
                return;
            }

            string finalName = _panelName.StartsWith("Wnd") ? _panelName : "Wnd" + _panelName;
            _onConfirm?.Invoke(finalName, _tempDesc);
            Close();
        }
    }
    public static class EditorWindowExtensions
    {
        public static void CenterOnMainWin(this EditorWindow window)
        {
            var main = EditorGUIUtility.GetMainWindowPosition();
            var pos = window.position;
            pos.x = main.x + (main.width - pos.width) * 0.5f;
            pos.y = main.y + (main.height - pos.height) * 0.5f;
            window.position = pos;
        }
    }

    public static class UIEditorHelper
    {
        private static readonly HashSet<string> CSharpKeywords = new HashSet<string>
        {
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
            "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
            "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
            "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
            "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
            "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
            "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
            "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
            "using", "virtual", "void", "volatile", "while"
        };

        public static bool IsValidVariableName(string name, out string errorMessage)
        {
            errorMessage = "";
            if (string.IsNullOrEmpty(name)) { errorMessage = "名称不能为空"; return false; }
            if (CSharpKeywords.Contains(name)) { errorMessage = $"'{name}' 是 C# 关键字"; return false; }
            if (char.IsDigit(name[0])) { errorMessage = "不能以数字开头"; return false; }
            if (!Regex.IsMatch(name, @"^[a-zA-Z_][a-zA-Z0-9_]*$")) { errorMessage = "只能包含字母数字下划线"; return false; }
            return true;
        }

        public static string GetRelativePath(Transform child, Transform root)
        {
            if (child == root) return string.Empty;
            string path = child.name;
            Transform parent = child.parent;
            while (parent != null && parent != root)
            {
                path = parent.name + "/" + path;
                parent = parent.parent;
            }
            return path;
        }

        /// <summary>
        /// 将绝对路径转换为以 Assets 开头的相对路径
        /// </summary>
        public static string ToAssetPath(string fullPath)
        {
            fullPath = fullPath.Replace("\\", "/");
            if (fullPath.StartsWith(Application.dataPath))
            {
                return "Assets" + fullPath.Substring(Application.dataPath.Length);
            }
            // 如果已经是相对路径则直接处理
            int assetsIndex = fullPath.IndexOf("/Assets/");
            if (assetsIndex != -1) return fullPath.Substring(assetsIndex + 1);
            if (fullPath.StartsWith("Assets/")) return fullPath;

            return fullPath;
        }
    }

    #endregion
}
