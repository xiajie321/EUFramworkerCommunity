using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Rendering.Universal;
using UnityEngine.UI;
using YooAsset;

namespace Framework
{
    public class UIKit : Singleton<UIKit>
    {
        private GameObject _uiRoot;

        private Camera _uiCamera;

        private CanvasScaler _canvasScaler;

        private Dictionary<UILayerEnum, RectTransform> _layers = new Dictionary<UILayerEnum, RectTransform>();

        private Dictionary<string, IUIPanel> _panels = new Dictionary<string, IUIPanel>();

        private Dictionary<string, AssetHandle> _assetHandles = new Dictionary<string, AssetHandle>();
        private ConcurrentDictionary<string, byte> _opening = new();

        private Stack<string> _panelStack = new Stack<string>();
        #region UI 初始化
        protected override void Initialize()
        {
            _layers.Clear();
            _panels.Clear();
            _assetHandles.Clear();
            _panelStack.Clear();

            if (GameBoot.Instance.UIRoot == null)
            {
                GameObject uiRoot = new GameObject("UIRoot", typeof(Canvas), typeof(CanvasScaler), typeof(GraphicRaycaster));
                //设置为UI层级
                uiRoot.layer = LayerMask.NameToLayer("UI");

                uiRoot.transform.SetParent(GameBoot.Instance.transform, false);

                uiRoot.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
                uiRoot.transform.localScale = Vector3.one;
                GameBoot.Instance.UIRoot = uiRoot;
            }

            _uiRoot = GameBoot.Instance.UIRoot;

            //判断有无 Canvas组件
            if (_uiRoot.GetComponent<Canvas>() == null)
            {
                _uiRoot.AddComponent<Canvas>();
            }

            // 添加 GraphicRaycaster 组件（用于 UI 点击检测）
            if (_uiRoot.GetComponent<GraphicRaycaster>() == null)
            {
                _uiRoot.AddComponent<GraphicRaycaster>();
            }

            // 确保 EventSystem 存在
            if (UnityEngine.EventSystems.EventSystem.current == null)
            {
                GameObject eventSystemGO = new GameObject("EventSystem");
                eventSystemGO.transform.parent = GameBoot.Instance.transform;
                eventSystemGO.AddComponent<UnityEngine.EventSystems.EventSystem>();
                eventSystemGO.AddComponent<UnityEngine.EventSystems.StandaloneInputModule>();
            }

            InitAdapter();
            InitUICamera();
        }


        private void InitAdapter()
        {
            //判断有无 CanvasScaler组件
            if (_uiRoot.GetComponent<CanvasScaler>() == null)
            {
                _uiRoot.AddComponent<CanvasScaler>();
            }
            _canvasScaler = _uiRoot.GetComponent<CanvasScaler>();
            //设置 ui scale mode 为 scale with screen size
            _canvasScaler.uiScaleMode = CanvasScaler.ScaleMode.ScaleWithScreenSize;
            //设置 ui reference resolution 为 1920*1080
            Vector2 refRes = new Vector2(1920, 1080);
            _canvasScaler.referenceResolution = refRes;

            // 根据设计分辨率判断横竖屏
            if (refRes.x > refRes.y)
            {
                // 横屏游戏，匹配宽度
                _canvasScaler.matchWidthOrHeight = 0f;
            }
            else
            {
                // 竖屏游戏，匹配高度
                _canvasScaler.matchWidthOrHeight = 1f;
            }
        }

        private void InitUICamera()
        {
            if (GameBoot.Instance.UICamera == null)
            {
                GameBoot.Instance.UICamera = new GameObject("UICamera").AddComponent<Camera>();
            }
            GameBoot.Instance.UICamera.transform.SetParent(GameBoot.Instance.transform, false);
            GameBoot.Instance.UICamera.transform.SetLocalPositionAndRotation(Vector3.zero, Quaternion.identity);
            GameBoot.Instance.UICamera.transform.localScale = Vector3.one;
            _uiCamera = GameBoot.Instance.UICamera;
            // 根据 Canvas 的参考分辨率设置 orthographicSize
            float referenceHeight = _canvasScaler.referenceResolution.y; // 1080
            _uiCamera.orthographicSize = referenceHeight / 2f / 100f; // 5.4f

            _uiCamera.depth = 100;
            _uiCamera.nearClipPlane = 0.1f;
            _uiCamera.farClipPlane = 1000f;

            _uiCamera.clearFlags = CameraClearFlags.Depth; // 只清除深度
            _uiCamera.cullingMask = 1 << LayerMask.NameToLayer("UI"); // 只渲染 UI 层
            _uiCamera.orthographic = true; // 明确设置为正交相机


            // 将 UI Camera 添加到 MainCamera 的 Stack 中（URP 相机堆叠）
            var mainCamera = GameBoot.Instance.GetMainCamera();
            if (mainCamera != null)
            {
                var cameraData = mainCamera.GetUniversalAdditionalCameraData();
                var uiCameraData = _uiCamera.GetUniversalAdditionalCameraData();
                // 将 UI Camera 添加到堆叠列表  
                uiCameraData.renderType = CameraRenderType.Overlay;
                cameraData.cameraStack.Add(_uiCamera);
            }
            else
            {
                UniLogger.LogWarning("UIKit: MainCamera 不存在，无法添加到 Stack");
            }

            // 设置 Canvas 为 Camera 模式
            Canvas canvas = _uiRoot.GetComponent<Canvas>();
            canvas.renderMode = RenderMode.ScreenSpaceCamera;
            canvas.worldCamera = _uiCamera;
            canvas.planeDistance = 100f; // Canvas 到相机的距离
        }

        public async UniTask InitUIAsync()
        {
            //初始化UI层级 根据UIEnum进行创建
            foreach (UILayerEnum layer in Enum.GetValues(typeof(UILayerEnum)))
            {
                // 使用构造函数直接创建带有 RectTransform 的 GameObject
                GameObject layerObject = new GameObject(layer.ToString(), typeof(RectTransform));

                //设置 layerObject 的 layer 为 UI
                layerObject.layer = LayerMask.NameToLayer("UI");

                // 设置为 Canvas 的子对象
                layerObject.transform.SetParent(_uiRoot.transform, false);

                // 直接获取 RectTransform（已经存在）
                RectTransform rectTransform = layerObject.GetComponent<RectTransform>();

                // 设置锚点铺满整个 Canvas
                rectTransform.anchorMin = Vector2.zero;
                rectTransform.anchorMax = Vector2.one;
                rectTransform.sizeDelta = Vector2.zero;
                rectTransform.anchoredPosition = Vector2.zero;

                // 设置层级顺序（根据枚举值）
                rectTransform.SetSiblingIndex((int)layer);

                //等待一帧
                await UniTask.Yield();

                //添加到字典
                _layers.TryAdd(layer, rectTransform);
            }
        }
        public RectTransform GetLayer(UILayerEnum layerType)
        {
            return _layers.TryGetValue(layerType, out var layer) ? layer : null;
        }
        #endregion

        #region UI 打开关闭相关

        /// <summary>
        /// 直接打开面板（不记录导航历史）
        /// 适用于弹窗、提示框等不需要返回功能的面板
        /// 如需导航历史，请使用 NavigateToPanelAsync
        /// </summary>
        public async UniTask OpenAsync<TPanel>(IUIPanelData data = null) where TPanel : UIPanelBase<TPanel>
        {
            var key = typeof(TPanel).Name;

            if (TryShowIfCached<TPanel>(key)) return;
            if (!TryEnterOpening(key)) return;

            // 1. 将变量声明在 try 外部，以便 catch 块可以访问
            TPanel panel = null;

            try
            {
                var prefab = await LoadUIAssetAsync(key);
                if (prefab == null)
                {
                    UniLogger.LogError($"[UI] 找不到预制体资源: {key}");
                    return;
                }

                panel = InstantiatePanel<TPanel>(prefab);

                // 2. 如果业务逻辑执行失败，进入 catch
                await panel.OpenAsync(data);

                FinishOpen(key, panel);
            }
            catch (Exception e)
            {
                UniLogger.LogError($"面板 {key} 打开过程报错：{e.Message}\n{e.StackTrace}");

                // 3. 核心改进：如果实例化成功了但初始化失败，销毁它防止残留
                if (panel != null && panel.gameObject != null)
                {
                    GameObject.Destroy(panel.gameObject);
                }
            }
            finally
            {
                _opening.TryRemove(key, out _);
            }
        }

        /// <summary>
        /// 独占式打开面板（关闭其他所有面板，清空导航历史）
        /// 适用于切换到全新流程，如：从大厅进入战斗
        /// </summary>
        public async UniTask OpenPanelExclusiveAsync<TPanel>(IUIPanelData data = null) where TPanel : UIPanelBase<TPanel>
        {
            var targetKey = typeof(TPanel).Name;

            bool isTargetOpen = _panels.ContainsKey(targetKey);

            if (!isTargetOpen)
            {
                await OpenAsync<TPanel>(data);
            }
            else
            {
                if (_panels.TryGetValue(targetKey, out var targetPanel))
                {
                    targetPanel.Show();
                }
            }

            CloseAllPanelsExcept<TPanel>();
        }

        /// <summary>
        /// 导航到指定面板（隐藏当前面板并记录历史）
        /// 适用于主流程页面，支持 BackToLastPanelAsync 返回上一页
        /// - 若目标面板已在栈顶，直接返回
        /// - 若目标面板在栈中，自动执行 BackToPanelAsync
        /// </summary>
        public async UniTask NavigateToPanelAsync<TPanel>(IUIPanelData data = null) where TPanel : UIPanelBase<TPanel>
        {
            var key = typeof(TPanel).Name;

            // 情况1：已经在栈顶，无需操作
            if (_panelStack.Count > 0 && _panelStack.Peek() == key)
            {
                return;
            }

            // 情况2：面板已在栈中但非栈顶 → 执行 BackTo
            if (_panelStack.Contains(key))
            {
                await BackToPanelAsync<TPanel>();
                return;
            }

            // 情况3：正常导航到新面板
            // 隐藏当前栈顶面板
            if (_panelStack.Count > 0)
            {
                var topKey = _panelStack.Peek();
                if (_panels.TryGetValue(topKey, out var topPanel))
                {
                    topPanel.Hide();
                }
            }

            // 打开新面板并压栈
            await OpenAsync<TPanel>(data);
            _panelStack.Push(key);
        }

        /// <summary>
        /// 返回上一个面板
        /// </summary>
        /// <param name="showNext">是否显示新的栈顶面板（循环调用时传 false 避免不必要的 Show/Hide）</param>
        public async UniTask BackToLastPanelAsync(bool showNext = true)
        {
            if (_panelStack.Count == 0)
            {
                UniLogger.LogWarning("[UIKit] 面板历史栈为空，无法返回");
                return;
            }

            // 弹出并关闭栈顶面板
            var topKey = _panelStack.Pop();
            if (_panels.TryGetValue(topKey, out var topPanel))
            {
                topPanel.Hide();
                if (topPanel.EnableClose)
                {
                    topPanel.Close();
                    _panels.Remove(topKey);

                    // 释放资源
                    if (_assetHandles.TryGetValue(topKey, out var assetHandle))
                    {
                        assetHandle.Release();
                        _assetHandles.Remove(topKey);
                    }
                }
            }

            await UniTask.Yield();

            // 只在需要时显示新的栈顶面板
            if (showNext && _panelStack.Count > 0)
            {
                var newTopKey = _panelStack.Peek();
                if (_panels.TryGetValue(newTopKey, out var newTopPanel))
                {
                    newTopPanel.Show();
                }
            }
        }

        /// <summary>
        /// 返回到指定面板（关闭中间所有面板）
        /// </summary>
        public async UniTask BackToPanelAsync<TPanel>() where TPanel : UIPanelBase<TPanel>
        {
            var targetKey = typeof(TPanel).Name;

            // 中间面板关闭时不显示新栈顶，避免不必要的 Show/Hide
            while (_panelStack.Count > 0 && _panelStack.Peek() != targetKey)
            {
                await BackToLastPanelAsync(showNext: false);
            }

            // 最后显示目标面板
            if (_panelStack.Count > 0 && _panels.TryGetValue(targetKey, out var targetPanel))
            {
                targetPanel.Show();
            }
        }

        /// <summary>
        /// 清空面板历史栈
        /// </summary>
        public async UniTask ClearPanelHistoryAsync()
        {
            // 清空时不需要显示任何面板
            while (_panelStack.Count > 0)
            {
                await BackToLastPanelAsync(showNext: false);
            }
        }

        /// <summary>
        /// 获取当前栈顶面板名称
        /// </summary>
        public string GetCurrentPanelName()
        {
            return _panelStack.Count > 0 ? _panelStack.Peek() : null;
        }

        /// <summary>
        /// 获取面板历史栈深度
        /// </summary>
        public int GetPanelHistoryCount()
        {
            return _panelStack.Count;
        }
        private bool TryShowIfCached<TPanel>(string key) where TPanel : UIPanelBase<TPanel>
        {
            if (_panels.TryGetValue(key, out var cached))
            {
                cached.Show();
                return true;
            }
            return false;
        }

        private bool TryEnterOpening(string key)
        {
            return _opening.TryAdd(key, 0);
        }

        /// <summary>
        /// 负责实例化 Panel 并处理层级挂载的方法
        /// </summary>
        private TPanel InstantiatePanel<TPanel>(GameObject prefab) where TPanel : UIPanelBase<TPanel>
        {
            var panelPrefab = prefab.GetComponent<TPanel>();
            var layer = GetLayer(panelPrefab.DefaultLayer);

            var go = GameObject.Instantiate(prefab, layer);
            var panel = go.GetComponent<TPanel>();

            if (go.TryGetComponent<RectTransform>(out var rect))
            {
                rect.localPosition = Vector3.zero;
                rect.localRotation = Quaternion.identity;
                rect.localScale = Vector3.one;
                //铺满
                rect.offsetMin = Vector2.zero;
                rect.offsetMax = Vector2.zero;
            }

            return panel;
        }

        private void FinishOpen<TPanel>(string key, UIPanelBase<TPanel> panel) where TPanel : UIPanelBase<TPanel>
        {
            _panels.TryAdd(key, panel);
            _opening.TryRemove(key, out _);
        }

        /// <summary>
        /// 直接关闭面板
        /// 适用于关闭弹窗、提示框等不需要导航历史的面板
        /// 如果面板在导航栈中，会自动从栈中移除
        /// </summary>
        public async UniTask CloseAsync<TPanel>() where TPanel : UIPanelBase<TPanel>
        {
            var key = typeof(TPanel).Name;

            if (_panels.TryGetValue(key, out var panel))
            {
                panel.Hide();
                if (!panel.EnableClose) return;
                panel.Close();
                _panels.Remove(key);

                // 如果面板在导航栈中，自动从栈中移除
                RemoveFromPanelStack(key);

                await UniTask.Yield();
                //释放AssetHandle
                if (_assetHandles.TryGetValue(key, out var assetHandle))
                {
                    assetHandle.Release();
                    _assetHandles.Remove(key);
                }
            }
        }

        /// <summary>
        /// 从导航栈中移除指定面板（内部方法）
        /// </summary>
        private void RemoveFromPanelStack(string key)
        {
            if (!_panelStack.Contains(key)) return;

            // Stack 不支持随机删除，需要重建
            var tempList = _panelStack.ToList();
            tempList.Remove(key);
            _panelStack.Clear();
            
            // 反转后重新压入（保持原有顺序）
            tempList.Reverse();
            foreach (var k in tempList)
            {
                _panelStack.Push(k);
            }
        }

        /// <summary>
        /// 关闭除指定面板外的所有面板（同时清空导航历史）
        /// 适用于切换到干净状态，只保留一个面板
        /// </summary>
        public void CloseAllPanelsExcept<TPanel>() where TPanel : UIPanelBase<TPanel>
        {
            var targetKey = typeof(TPanel).Name;

            var tempList = _panels.Keys.ToArray();

            foreach (var key in tempList)
            {
                if (key != targetKey)
                {
                    if (_panels.TryGetValue(key, out var panel))
                    {
                        panel.Hide();
                        if (!panel.EnableClose) continue;
                        panel.Close();
                        _panels.Remove(key);

                        if (_assetHandles.TryGetValue(key, out var assetHandle))
                        {
                            assetHandle.Release();
                            _assetHandles.Remove(key);
                        }
                    }
                }
            }

            // 清空导航历史
            _panelStack.Clear();
        }
        #endregion

        #region 资源加载辅助方法
        private async UniTask<GameObject> LoadUIAssetAsync(string panelName)
        {
            //判断缓存中是否拥有 有则直接进行获取
            if (_assetHandles.TryGetValue(panelName, out var assetHandle))
            {
                await assetHandle;
                return assetHandle.AssetObject as GameObject;
            }

            //先判断远程包 Assets/Res/Remote/UI/Prefabs 
            var remotePackage = ResKit.Instance.GetDefaultPackage();
            string assetPath = $"Assets/Res/Remote/UI/Prefabs/{panelName}.prefab";
            //如果首包没有 则进入首包获取 
            if (remotePackage == null || !remotePackage.CheckLocationValid(assetPath))
            {
                return await LoadUIBuiltinAssetAsync(panelName);
            }

            assetHandle = remotePackage.LoadAssetAsync(assetPath);
            await assetHandle;
            //缓存handle 
            _assetHandles.TryAdd(panelName, assetHandle);

            return assetHandle.AssetObject as GameObject;
        }

        /// <summary>
        /// 加载首包资源 ---  只在LoadUIAssetAsync 中调用--切是判断远程包加载不出来的时候
        /// </summary>
        /// <param name="panelName"></param>
        /// <returns></returns>        
        private async UniTask<GameObject> LoadUIBuiltinAssetAsync(string panelName)
        {
            //获取到首包获取 Assets/Res/Builtin/UI/Prefabs 
            string assetPath = $"Assets/Res/Builtin/UI/Prefabs/{panelName}.prefab";
            var builtinPackage = ResKit.Instance.GetBuiltinPackage();
            if (builtinPackage == null)
            {
                return null;
            }

            var assetHandle = builtinPackage.LoadAssetAsync(assetPath);
            await assetHandle;
            //缓存handle 
            _assetHandles.TryAdd(panelName, assetHandle);
            return assetHandle.AssetObject as GameObject;
        }
        #endregion
    }
}